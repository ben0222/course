### DFS
#### 算法关键
- 终止条件
- 递归逻辑
- 状态回退
- 需要记录的信息：参数

 #### 如何查找一个树两个路径的公共边？
 ##### 暴力方案：
 分别遍历两条路径，每遍历到一条边就给这条边权重+1。最后权重为2的边就是公共边。
##### 优化方案：
###### 树上差分、最近公共祖先
 （什么是差分？给数组的某一段增加？）
- 点权上的差分
- 边权上的差分（3517砍树）：点权=与他father相连那条边的边权
###### 树上差分过程：
  1. 路径的起点和终点：点权+1；
  2. 两个点的lca：点权-2；
最后：遍历每个点(bfs)，每个点加上其子树点权之和。此时点权=该点-其父节点的边权
#### 剪枝（买瓜）
- 当前方案已经不是最优解，可剪（当前刀数已经大于最优解）
- 后面所有方案都无法满足题意，可剪（后面瓜总和+现有重量都无法满足）
- 判断合法性：
  - 已有重量>需求重量
  - 瓜数量
代码实现：本质就是多了一个if判断，出现某种特殊情况直接return。所以能把越多特殊情况列出来，效率越高。

- 贪心思想的体现：将瓜从大到小排序 

```C++
    sort(a, a + n, Compare());
```
其中`a`为数组起始地址，`a+n`为数组终止地址，`Compare()`比较器
也可以写成lambda函数
```C++
sort(a, a + n, [&](int x, int y){return x > y;});
```
   
 比较器
```C++
struct Compare
{
    bool operator()(int x, int y)
    {
        return x > y;
    }
};
```
### 图的遍历
选定起点很重要

